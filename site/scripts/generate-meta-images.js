const path = require('path');
const fs = require('fs');
const puppeteer = require('puppeteer');
const matter = require('gray-matter');
const glob = require('glob');
const sidebars = require('../sidebars');

function getBreadcrumbs(file, sidebars) {
  const docId = file.replace(/\.md$/, '');
  const breadcrumbs = [];

  function traverse(items, parentLabel = null) {
    for (const item of items) {
      if (item.type === 'doc' && item.id === docId) {
        if (parentLabel) {
          breadcrumbs.unshift(parentLabel);
        }
        return true;
      } else if (item.type === 'category') {
        if (traverse(item.items || [], item.label)) {
          if (parentLabel) {
            breadcrumbs.unshift(parentLabel);
          }
          return true;
        }
      } else if (
        item.type === 'autogenerated' &&
        item.dirName &&
        file.startsWith(item.dirName + '/')
      ) {
        if (parentLabel) {
          breadcrumbs.unshift(parentLabel);
        }
        return true;
      }
    }
    return false;
  }

  traverse(sidebars.promptfoo);
  return breadcrumbs.join(' › ');
}

async function generateMetaImages() {
  const docsDir = path.join(__dirname, '..', 'docs');
  const outputDir = path.join(__dirname, '..', 'static/img/meta/docs');
  const templatePath = path.join(__dirname, '..', 'static/img/meta/docs-template.html');

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const template = fs.readFileSync(templatePath, 'utf8');
  const browser = await puppeteer.launch({
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
    protocolTimeout: 60000, // Increase timeout to 60 seconds
  });

  try {
    const files = glob.sync('**/*.md', { cwd: docsDir });
    console.log(`Found ${files.length} markdown files`);

    // Process files in batches of 5
    const batchSize = 5;
    for (let i = 0; i < files.length; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      const promises = batch.map(async (file) => {
        const page = await browser.newPage();
        await page.setViewport({ width: 1200, height: 630 });

        try {
          const filePath = path.join(docsDir, file);
          const content = fs.readFileSync(filePath, 'utf8');
          const { data: frontMatter, content: markdown } = matter(content);

          const existingImage = frontMatter.image?.replace(/^\//, '');
          if (existingImage && fs.existsSync(path.join(__dirname, '..', existingImage))) {
            console.log(`Skipping ${file} - already has image: ${existingImage}`);
            return;
          }

          const title =
            frontMatter.title || markdown.match(/^#\s+(.+)/m)?.[1] || path.basename(file, '.md');
          const breadcrumbs = getBreadcrumbs(file, sidebars);
          const preview =
            markdown
              .replace(/^#.*$/m, '')
              .replace(/[#\[\]*]/g, '')
              .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Remove markdown links but keep link text
              .replace(/^import.*$/gm, '')
              .replace(/\n{3,}/g, '\n\n') // Replace 3 or more newlines with 2
              .trim()
              .replace(/\n/g, '<br>')
              .slice(0, 200) + '...';

          const safeFilename = file.replace(/[^a-z0-9]/gi, '-').toLowerCase() + '.png';
          const outputPath = path.join(outputDir, safeFilename);
          const relativePath = path.join('img/meta/docs', safeFilename);

          const isRedTeam = file.includes('red-team') || file.includes('redteam');
          const gradientColors = isRedTeam
            ? `
              135deg,
              #571a1a 0%,
              #702525 25%,
              #852e2e 50%,
              #a04f4f 75%,
              #bb6b6b 100%
            `
            : `
              135deg,
              #1a4557 0%,
              #255d70 25%,
              #2e6585 50%,
              #4f8ca0 75%,
              #6ba5bb 100%
            `;

          const breadcrumbsHtml = breadcrumbs
            ? breadcrumbs
                .split(' › ')
                .map((part, index, array) => {
                  const pill = `
                    <div
                      style="
                        background: rgba(255, 255, 255, 0.15);
                        padding: 6px 16px;
                        border-radius: 100px;
                        backdrop-filter: blur(10px);
                      "
                    >
                      ${part}
                    </div>
                  `;
                  return index === array.length - 1
                    ? pill
                    : pill + '<div style="color: rgba(255, 255, 255, 0.6)">›</div>';
                })
                .join('')
            : '';

          const html = template
            .replace('{{title}}', title)
            .replace('{{#breadcrumbs}}', breadcrumbs ? '' : '<!--')
            .replace('{{/breadcrumbs}}', breadcrumbs ? '' : '-->')
            .replace('{{breadcrumbsHtml}}', breadcrumbsHtml)
            .replace('{{preview}}', preview)
            .replace('{{gradientColors}}', gradientColors);

          // Try screenshot with retries
          let retries = 3;
          while (retries > 0) {
            try {
              await page.setContent(html, { waitUntil: 'networkidle0', timeout: 30000 });
              await page.screenshot({
                path: outputPath,
                type: 'png',
                timeout: 30000,
              });
              break;
            } catch (error) {
              retries--;
              if (retries === 0) {
                console.error(`Failed to generate image for ${file} after 3 retries:`, error);
                throw error;
              }
              console.warn(`Retrying screenshot for ${file}, ${retries} attempts remaining`);
              await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second before retry
            }
          }
          console.log(`Generated image for ${file} at ${outputPath}`);

          const newFrontMatter = {
            ...frontMatter,
            image: '/' + relativePath.replace(/\\/g, '/'),
          };

          const updatedContent = matter.stringify(markdown, newFrontMatter);
          fs.writeFileSync(filePath, updatedContent);
        } finally {
          await page.close();
        }
      });

      await Promise.all(promises);
    }
  } finally {
    await browser.close();
  }
}

generateMetaImages().catch(console.error);
